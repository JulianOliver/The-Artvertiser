<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>bazar: /home/julian/devel/artvertiser/starter/geometry/projection_matrix.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_dda6bb14f03450b8a577b3d18e5342c4.html">starter</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_26fbf16915a8098e08b4b18346c54330.html">geometry</a>
  </div>
</div>
<div class="contents">
<h1>projection_matrix.cpp</h1><a href="projection__matrix_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Copyright 2005, 2006 Computer Vision Lab, </span>
<a name="l00003"></a>00003 <span class="comment">Ecole Polytechnique Federale de Lausanne (EPFL), Switzerland. </span>
<a name="l00004"></a>00004 <span class="comment">All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">This file is part of BazAR.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">BazAR is free software; you can redistribute it and/or modify it under the</span>
<a name="l00009"></a>00009 <span class="comment">terms of the GNU General Public License as published by the Free Software</span>
<a name="l00010"></a>00010 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
<a name="l00011"></a>00011 <span class="comment">version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">BazAR is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<a name="l00014"></a>00014 <span class="comment">WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A</span>
<a name="l00015"></a>00015 <span class="comment">PARTICULAR PURPOSE. See the GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">You should have received a copy of the GNU General Public License along with</span>
<a name="l00018"></a>00018 <span class="comment">BazAR; if not, write to the Free Software Foundation, Inc., 51 Franklin</span>
<a name="l00019"></a>00019 <span class="comment">Street, Fifth Floor, Boston, MA 02110-1301, USA </span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;float.h&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="linear__algebra_8h.html">math/linear_algebra.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "<a class="code" href="projection__matrix_8h.html">projection_matrix.h</a>"</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">using namespace </span>std;
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="classprojection__matrix.html#e8eca94a6301e6863d81dc6ed2742001">00031</a> <a class="code" href="classprojection__matrix.html#e8eca94a6301e6863d81dc6ed2742001">projection_matrix::projection_matrix</a>(<span class="keywordtype">void</span>)
<a name="l00032"></a>00032 {
<a name="l00033"></a>00033   planes[0] = 0;
<a name="l00034"></a>00034   planes[1] = 0;
<a name="l00035"></a>00035   planes[2] = 100;
<a name="l00036"></a>00036   planes[3] = 0;
<a name="l00037"></a>00037   planes[4] = -100;
<a name="l00038"></a>00038   planes[5] = 10000;
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="classprojection__matrix.html#5df0e379e9223666372f4f7504bb8ae3">00041</a> <a class="code" href="classprojection__matrix.html#5df0e379e9223666372f4f7504bb8ae3">projection_matrix::~projection_matrix</a>()
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="classprojection__matrix.html#2570d4e5654da3890f75216443ae7549">00045</a> <a class="code" href="classprojection__matrix.html" title="3D to 2D projection matrix">projection_matrix</a> &amp;<a class="code" href="classprojection__matrix.html#2570d4e5654da3890f75216443ae7549">projection_matrix::operator=</a>(<span class="keyword">const</span> <a class="code" href="classprojection__matrix.html" title="3D to 2D projection matrix">projection_matrix</a> &amp;copied)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047   cx = copied.<a class="code" href="classprojection__matrix.html#c8ffab1c130be53572b3eb26eb41e77a">cx</a>;
<a name="l00048"></a>00048   cy = copied.<a class="code" href="classprojection__matrix.html#33e037f62f892351b6c5ba5004e69704">cy</a>;
<a name="l00049"></a>00049   fx = copied.<a class="code" href="classprojection__matrix.html#811259e5eec0bd792f7964c3d83a6c05">fx</a>;
<a name="l00050"></a>00050   fy = copied.<a class="code" href="classprojection__matrix.html#0a016cbda53ef8ebc1f3b067897d9d2c">fy</a>;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   image_width = copied.<a class="code" href="classprojection__matrix.html#8978eea87cb0e722b4f6a3429cfaa006">image_width</a>;
<a name="l00053"></a>00053   image_height = copied.<a class="code" href="classprojection__matrix.html#d874c0c1c7644a86010c5858532f7bf2">image_height</a>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   original_cx = copied.<a class="code" href="classprojection__matrix.html#f86134460780aa6196a857993ce96b2f">original_cx</a>;
<a name="l00056"></a>00056   original_cy = copied.<a class="code" href="classprojection__matrix.html#6ff5c3ad18460b732666274bcb021460">original_cy</a>;
<a name="l00057"></a>00057   original_fx = copied.<a class="code" href="classprojection__matrix.html#c42d4b0c3754f878323de3d538f24135">original_fx</a>;
<a name="l00058"></a>00058   original_fy = copied.<a class="code" href="classprojection__matrix.html#e23e168c6c5f101915e7a9afe5bf6cd1">original_fy</a>;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   original_image_width = copied.<a class="code" href="classprojection__matrix.html#144dd0b375b5e39e0b6ccf07f1728470">original_image_width</a>;
<a name="l00061"></a>00061   original_image_height = copied.<a class="code" href="classprojection__matrix.html#a47d58f0977f4ca5ecbc33ee6936641b">original_image_height</a>;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <a class="code" href="linear__algebra_8cpp.html#2fd7f823ed13ef80bbf7f107eace90db">gfla_copy_3x3</a>(copied.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>, R);
<a name="l00064"></a>00064   <a class="code" href="linear__algebra_8cpp.html#d4470ae6b1e9aeb6dac4275f1e5ef868">gfla_copy_3</a>(copied.<a class="code" href="classprojection__matrix.html#53564d62553e7c740bcdfd784c28a598">T</a>, T);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keywordtype">void</span> projection_matrix::getAAt(<span class="keyword">const</span> <span class="keywordtype">double</span> P[3][4], <span class="keywordtype">double</span> AAt[3][3])
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073   <span class="keywordtype">double</span> t7 = P[0][0]*P[0][0];
<a name="l00074"></a>00074   <span class="keywordtype">double</span> t8 = P[0][1]*P[0][1];
<a name="l00075"></a>00075   <span class="keywordtype">double</span> t9 = P[0][2]*P[0][2];
<a name="l00076"></a>00076   <span class="keywordtype">double</span> t14 = P[0][0]*P[1][0]+P[0][1]*P[1][1]+P[0][2]*P[1][2];
<a name="l00077"></a>00077   <span class="keywordtype">double</span> t18 = P[0][0]*P[2][0]+P[0][1]*P[2][1]+P[0][2]*P[2][2];
<a name="l00078"></a>00078   <span class="keywordtype">double</span> t19 = P[1][0]*P[1][0];
<a name="l00079"></a>00079   <span class="keywordtype">double</span> t20 = P[1][1]*P[1][1];
<a name="l00080"></a>00080   <span class="keywordtype">double</span> t21 = P[1][2]*P[1][2];
<a name="l00081"></a>00081   <span class="keywordtype">double</span> t26 = P[1][0]*P[2][0]+P[1][1]*P[2][1]+P[1][2]*P[2][2];
<a name="l00082"></a>00082   <span class="keywordtype">double</span> t27 = P[2][0]*P[2][0];
<a name="l00083"></a>00083   <span class="keywordtype">double</span> t28 = P[2][1]*P[2][1];
<a name="l00084"></a>00084   <span class="keywordtype">double</span> t29 = P[2][2]*P[2][2];
<a name="l00085"></a>00085   AAt[0][0] = t7+t8+t9;
<a name="l00086"></a>00086   AAt[0][1] = t14;
<a name="l00087"></a>00087   AAt[0][2] = t18;
<a name="l00088"></a>00088   AAt[1][0] = t14;
<a name="l00089"></a>00089   AAt[1][1] = t19+t20+t21;
<a name="l00090"></a>00090   AAt[1][2] = t26;
<a name="l00091"></a>00091   AAt[2][0] = t18;
<a name="l00092"></a>00092   AAt[2][1] = t26;
<a name="l00093"></a>00093   AAt[2][2] = t27+t28+t29;
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="classprojection__matrix.html#240ff343491ec5fdd1ede5a622786ffe">00096</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#240ff343491ec5fdd1ede5a622786ffe">projection_matrix::set_3x4_matrix</a>(<span class="keywordtype">double</span> P[3][4], <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098   image_width  = w;
<a name="l00099"></a>00099   image_height = h;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordtype">double</span> inv_l = sqrt(P[2][0] * P[2][0] + P[2][1] * P[2][1] + P[2][2] * P[2][2]);
<a name="l00102"></a>00102   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00103"></a>00103     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00104"></a>00104       P[i][j] = inv_l * P[i][j];
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   R[2][0] = P[2][0];
<a name="l00107"></a>00107   R[2][1] = P[2][1];
<a name="l00108"></a>00108   R[2][2] = P[2][2];
<a name="l00109"></a>00109   T[2]    = P[2][3];
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="keywordtype">double</span> AAt[3][3];
<a name="l00112"></a>00112   getAAt(P, AAt);
<a name="l00113"></a>00113   cx = AAt[2][0];
<a name="l00114"></a>00114   cy = AAt[2][1];
<a name="l00115"></a>00115   fy = sqrt(AAt[1][1] - cy * cy);
<a name="l00116"></a>00116   <span class="keywordtype">double</span> s = (AAt[1][0] - cx * cy) / fy;
<a name="l00117"></a>00117   fx = sqrt(AAt[0][0] - cx * cx - s * s);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   R[1][0] = (P[1][0] - cy * R[2][0]) / fy;
<a name="l00120"></a>00120   R[0][0] = (P[0][0] - s * R[1][0] - cx * R[2][0]) / fx; 
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   R[1][1] = (P[1][1] - cy * R[2][1]) / fy;
<a name="l00123"></a>00123   R[0][1] = (P[0][1] - s * R[1][1] - cx * R[2][1]) / fx; 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   R[1][2] = (P[1][2] - cy * R[2][2]) / fy;
<a name="l00126"></a>00126   R[0][2] = (P[0][2] - s * R[1][2] - cx * R[2][2]) / fx; 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   T[1] = (P[1][3] - cy * T[2]) / fy;
<a name="l00129"></a>00129   T[0] = (P[0][3] - s * T[1] - cx * T[2]) / fx;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   <span class="keywordflow">if</span> (<a class="code" href="linear__algebra_8cpp.html#a0ac55d232b5c9cc6a2b59e92891d13c">gfla_det</a>(R) &lt; 0) {
<a name="l00132"></a>00132     fy = -fy; <span class="comment">// ??</span>
<a name="l00133"></a>00133     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) 
<a name="l00134"></a>00134       R[1][i] = -R[1][i];
<a name="l00135"></a>00135     T[1] = -T[1];
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00146"></a><a class="code" href="classprojection__matrix.html#d0162d407b33717426a135157459b34a">00146</a> <span class="keywordtype">bool</span> <a class="code" href="classprojection__matrix.html#4938516828f52f859c494d7ec1d03577">projection_matrix::load_tdir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tdir_filename, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148   ifstream file;
<a name="l00149"></a>00149   file.open(tdir_filename);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (!file.good()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00152"></a>00152   <span class="keywordtype">double</span> P[3][4];
<a name="l00153"></a>00153 
<a name="l00154"></a>00154   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;3; ++j) 
<a name="l00155"></a>00155     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;4; ++i) 
<a name="l00156"></a>00156       file &gt;&gt; P[j][i];
<a name="l00157"></a>00157   file.close();
<a name="l00158"></a>00158   <a class="code" href="classprojection__matrix.html#240ff343491ec5fdd1ede5a622786ffe">set_3x4_matrix</a>(P, w, h);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="projection__matrix_8cpp.html#b70d90d2e64aedbc915676082751197d">00163</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="camera_8cpp.html#b70d90d2e64aedbc915676082751197d">diag</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165   <span class="keywordflow">return</span> sqrt(x*x+y*y);
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="projection__matrix_8cpp.html#6c810cf1a52aa4b2c66773de92030aea">00168</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="camera_8cpp.html#2c00c2883cc79ab83c17c0ca6c135387">diagDiff</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="yape_8cpp.html#649b8f01fd6c0f47ff3cbddaeba63bfb">W</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> H, <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170   <span class="keywordtype">double</span> mdiag = <a class="code" href="camera_8cpp.html#b70d90d2e64aedbc915676082751197d">diag</a>(<span class="keywordtype">double</span>(W), <span class="keywordtype">double</span>(H));
<a name="l00171"></a>00171   <span class="keywordflow">return</span> fabs(<span class="keywordtype">double</span>(mdiag - <a class="code" href="camera_8cpp.html#b70d90d2e64aedbc915676082751197d">diag</a>(2 * dx, 2 * dy)));
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00181"></a><a class="code" href="classprojection__matrix.html#4938516828f52f859c494d7ec1d03577">00181</a> <span class="keywordtype">bool</span> <a class="code" href="classprojection__matrix.html#4938516828f52f859c494d7ec1d03577">projection_matrix::load_tdir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tdir_filename)
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183   <span class="keywordflow">if</span> (!<a class="code" href="classprojection__matrix.html#4938516828f52f859c494d7ec1d03577">load_tdir</a>(tdir_filename, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> modes[] = {
<a name="l00186"></a>00186       640, 480,
<a name="l00187"></a>00187       320, 240,
<a name="l00188"></a>00188       720, 576,
<a name="l00189"></a>00189       360, 288,
<a name="l00190"></a>00190       800, 600,
<a name="l00191"></a>00191       1024, 768,
<a name="l00192"></a>00192       512, 384,
<a name="l00193"></a>00193       1280, 1024,
<a name="l00194"></a>00194       -1, -1
<a name="l00195"></a>00195   };
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="keywordtype">int</span> best = 0;
<a name="l00198"></a>00198   <span class="keywordtype">double</span> bestDelta = <a class="code" href="camera_8cpp.html#2c00c2883cc79ab83c17c0ca6c135387">diagDiff</a>(modes[0], modes[1], cx, cy); 
<a name="l00199"></a>00199   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; modes[2 * i] != -1; i++) {
<a name="l00200"></a>00200     <span class="keywordtype">double</span> delta = <a class="code" href="camera_8cpp.html#2c00c2883cc79ab83c17c0ca6c135387">diagDiff</a>(modes[2 * i], modes[2 * i + 1], cx, cy);
<a name="l00201"></a>00201     <span class="keywordflow">if</span> (delta &lt; bestDelta) {
<a name="l00202"></a>00202       best = i;
<a name="l00203"></a>00203       bestDelta = delta;
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   image_width  = modes[2 * best];
<a name="l00208"></a>00208   image_height = modes[best + 1];
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="classprojection__matrix.html#9e6dd26f4eba86d8c441c0163d54e279">00213</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#9e6dd26f4eba86d8c441c0163d54e279">projection_matrix::load</a>(FILE * f)
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215   <span class="keywordtype">char</span> calibration_name[500];
<a name="l00216"></a>00216   <span class="keywordtype">int</span> dummy;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   fscanf(f,<span class="stringliteral">"%s"</span>, calibration_name);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   fscanf(f, <span class="stringliteral">"%d"</span>, &amp;dummy);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="keywordflow">if</span> (dummy != -1) <span class="comment">// To correct incompatibility with older versions of keyframes</span>
<a name="l00223"></a>00223     fscanf(f, <span class="stringliteral">"%d"</span>, &amp;dummy);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <a class="code" href="classprojection__matrix.html#a2224d4f204527196e17241db7a90847">read_internal_parameters_from_tdir_file</a>(calibration_name);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(optical_centre[0]), &amp;(optical_centre[1]), &amp;(optical_centre[2]));
<a name="l00228"></a>00228   fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(R[0][0]), &amp;(R[0][1]), &amp;(R[0][2]));
<a name="l00229"></a>00229   fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(R[1][0]), &amp;(R[1][1]), &amp;(R[1][2]));
<a name="l00230"></a>00230   fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(R[2][0]), &amp;(R[2][1]), &amp;(R[2][2]));
<a name="l00231"></a>00231   fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(T[0]),     &amp;(T[1]),    &amp;(T[2]));
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keywordtype">void</span> projection_matrix::read_one_line(FILE * f, <span class="keywordtype">char</span> * line)
<a name="l00237"></a>00237 {
<a name="l00238"></a>00238   <span class="keywordtype">int</span> n = 0;
<a name="l00239"></a>00239   <span class="keywordtype">char</span> c;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="keywordflow">do</span>
<a name="l00242"></a>00242   {
<a name="l00243"></a>00243     fscanf(f, <span class="stringliteral">"%c"</span>, &amp;c);
<a name="l00244"></a>00244     line[n] = c;
<a name="l00245"></a>00245     n++;
<a name="l00246"></a>00246   } <span class="keywordflow">while</span> (c != <span class="charliteral">'\n'</span>);
<a name="l00247"></a>00247   n = n - 2; <span class="comment">// Skip the (char)13 and the (char)10:</span>
<a name="l00248"></a>00248   line[n] = <span class="charliteral">'\0'</span>;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a><a class="code" href="classprojection__matrix.html#4f20d900e99e28adc83a4f5de8d99fff">00251</a> FILE * <a class="code" href="classprojection__matrix.html#4f20d900e99e28adc83a4f5de8d99fff">projection_matrix::open_matchmover_output</a>(<span class="keywordtype">char</span> * filename)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253   FILE * f = fopen(filename, <span class="stringliteral">"r"</span>);
<a name="l00254"></a>00254   <span class="keywordtype">char</span> line[1000];
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="keywordflow">if</span> (f == NULL)
<a name="l00257"></a>00257     <span class="keywordflow">return</span> NULL;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordflow">do</span> {
<a name="l00260"></a>00260     read_one_line(f, line);
<a name="l00261"></a>00261   } <span class="keywordflow">while</span> (strcmp(line, <span class="stringliteral">"Camera"</span>) != 0);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   read_one_line(f, line);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="keywordflow">return</span> f;
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a><a class="code" href="classprojection__matrix.html#39c83dc144544146339e345031da124e">00268</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#39c83dc144544146339e345031da124e">projection_matrix::close_matchmover_output</a>(FILE * f)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270   fclose(f);
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00273"></a><a class="code" href="classprojection__matrix.html#36c6fc6a6787cb14b4bda7f71bd33ca6">00273</a> <span class="keywordtype">bool</span> <a class="code" href="classprojection__matrix.html#36c6fc6a6787cb14b4bda7f71bd33ca6">projection_matrix::read_from_matchmover_output</a>(FILE * f)
<a name="l00274"></a>00274 {
<a name="l00275"></a>00275   <span class="keywordtype">int</span> camera_index;
<a name="l00276"></a>00276   <span class="keywordtype">double</span> focale_length, pixel_ratio, principal_point_u, principal_point_v, K;
<a name="l00277"></a>00277   <span class="keywordtype">double</span> Oc[3], local_R[3][3], local_t[3];
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">"\t%d"</span>, &amp;camera_index) != 1)
<a name="l00280"></a>00280   {
<a name="l00281"></a>00281     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (1)."</span> &lt;&lt; endl;
<a name="l00282"></a>00282     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00283"></a>00283   }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">"\t F ( %lf ) Pr ( %lf ) Pp ( %lf %lf ) K ( %lf )"</span>,
<a name="l00286"></a>00286     &amp;focale_length, &amp;pixel_ratio, &amp;principal_point_u, &amp;principal_point_v, &amp;K) != 5)
<a name="l00287"></a>00287   {
<a name="l00288"></a>00288     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (2)."</span> &lt;&lt; endl;
<a name="l00289"></a>00289     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">"\tOc ( %lf %lf %lf )"</span>, &amp;(Oc[0]), &amp;(Oc[1]), &amp;(Oc[2])) != 3)
<a name="l00293"></a>00293   {
<a name="l00294"></a>00294     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (3)."</span> &lt;&lt; endl;
<a name="l00295"></a>00295     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">"\tRot ( %lf %lf %lf"</span>, &amp;(local_R[0][0]), &amp;(local_R[0][1]), &amp;(local_R[0][2])) != 3)
<a name="l00299"></a>00299   {
<a name="l00300"></a>00300     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (4)."</span> &lt;&lt; endl;
<a name="l00301"></a>00301     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">"%lf %lf %lf"</span>, &amp;(local_R[1][0]), &amp;(local_R[1][1]), &amp;(local_R[1][2])) != 3)
<a name="l00305"></a>00305   {
<a name="l00306"></a>00306     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (5)."</span> &lt;&lt; endl;
<a name="l00307"></a>00307     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00308"></a>00308   }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="keywordflow">if</span> (fscanf(f, <span class="stringliteral">" %lf %lf %lf )"</span>, &amp;(local_R[2][0]), &amp;(local_R[2][1]), &amp;(local_R[2][2])) != 3)
<a name="l00311"></a>00311   {
<a name="l00312"></a>00312     cerr &lt;&lt; <span class="stringliteral">"Error while reading matchmover output (6)."</span> &lt;&lt; endl;
<a name="l00313"></a>00313     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00314"></a>00314   }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <a class="code" href="classprojection__matrix.html#be82e2e88b2cc76938f3a5d6a32d3099">set_original_internal_parameters</a>(<span class="keywordtype">int</span>(2 * principal_point_u), <span class="keywordtype">int</span>(2 * principal_point_v), <span class="comment">// image size</span>
<a name="l00317"></a>00317     focale_length, pixel_ratio * focale_length, 
<a name="l00318"></a>00318     principal_point_u, principal_point_v);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <a class="code" href="linear__algebra_8cpp.html#9309c81793fbfbc63335878dca693d5e">gfla_mul_mat_vect_3x3</a>(local_R, Oc, local_t);
<a name="l00321"></a>00321   <a class="code" href="linear__algebra_8cpp.html#82d3dd48d4e2eb5f04775d0e867ea04a">gfla_opp_3</a>(local_t);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">set_external_parameters</a>(local_R, local_t);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a><a class="code" href="projection__matrix_8h.html#ba397ab7b0ab5343b707c2ddd49ca18a">00328</a> ostream&amp; <a class="code" href="classprojection__matrix.html#ba397ab7b0ab5343b707c2ddd49ca18a">operator&lt;&lt; </a>(ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classprojection__matrix.html" title="3D to 2D projection matrix">projection_matrix</a>&amp; P)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330   o &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#811259e5eec0bd792f7964c3d83a6c05">fx</a> &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; 0    &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c8ffab1c130be53572b3eb26eb41e77a">cx</a> &lt;&lt; <span class="stringliteral">"\t]["</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[0][0] &lt;&lt; <span class="stringliteral">"\t"</span>  &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[0][1] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[0][2] &lt;&lt; <span class="stringliteral">" | "</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#53564d62553e7c740bcdfd784c28a598">T</a>[0] &lt;&lt; <span class="stringliteral">" ]"</span> &lt;&lt; endl;
<a name="l00331"></a>00331   o &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; 0    &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#0a016cbda53ef8ebc1f3b067897d9d2c">fy</a> &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#33e037f62f892351b6c5ba5004e69704">cy</a> &lt;&lt; <span class="stringliteral">"\t]["</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[1][0] &lt;&lt; <span class="stringliteral">"\t"</span>  &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[1][1] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[1][2] &lt;&lt; <span class="stringliteral">" | "</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#53564d62553e7c740bcdfd784c28a598">T</a>[1] &lt;&lt; <span class="stringliteral">" ]"</span> &lt;&lt; endl;
<a name="l00332"></a>00332   o &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; 0    &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; 0    &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; 1    &lt;&lt; <span class="stringliteral">"\t]["</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[2][0] &lt;&lt; <span class="stringliteral">"\t"</span>  &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[2][1] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#c9850217c857a4b19f07e865ed14c30a">R</a>[2][2] &lt;&lt; <span class="stringliteral">" | "</span> &lt;&lt; P.<a class="code" href="classprojection__matrix.html#53564d62553e7c740bcdfd784c28a598">T</a>[2] &lt;&lt; <span class="stringliteral">" ]"</span> &lt;&lt; endl;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="keywordflow">return</span> o;
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a><a class="code" href="classprojection__matrix.html#c225ef5217d1925478e842bd5686361a">00337</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#c225ef5217d1925478e842bd5686361a">projection_matrix::print</a>(FILE * file, <span class="keywordtype">char</span> * calibration_filename)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339   fprintf(file, <span class="stringliteral">"%s\n"</span>, calibration_filename);
<a name="l00340"></a>00340   fprintf(file, <span class="stringliteral">"0\n"</span>);  <span class="comment">// Compatibility reasons</span>
<a name="l00341"></a>00341   fprintf(file, <span class="stringliteral">"-1\n"</span>); <span class="comment">// Idem</span>
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <span class="keywordflow">if</span> (have_to_recompute_optical_centre)
<a name="l00344"></a>00344     compute_optical_centre();
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   fprintf(file, <span class="stringliteral">"%lf %lf %lf "</span>, optical_centre[0], optical_centre[1], optical_centre[2]);
<a name="l00347"></a>00347   fprintf(file, <span class="stringliteral">"%lf %lf %lf "</span>, R[0][0], R[0][1], R[0][2]);
<a name="l00348"></a>00348   fprintf(file, <span class="stringliteral">"%lf %lf %lf "</span>, R[1][0], R[1][1], R[1][2]);
<a name="l00349"></a>00349   fprintf(file, <span class="stringliteral">"%lf %lf %lf "</span>, R[2][0], R[2][1], R[2][2]);
<a name="l00350"></a>00350   fprintf(file, <span class="stringliteral">"%lf %lf %lf "</span>, T[0],    T[1],    T[2]);
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00354"></a>00354 <span class="comment">// Internal parameters:</span>
<a name="l00355"></a>00355 
<a name="l00356"></a><a class="code" href="classprojection__matrix.html#be82e2e88b2cc76938f3a5d6a32d3099">00356</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#be82e2e88b2cc76938f3a5d6a32d3099">projection_matrix::set_original_internal_parameters</a>(<span class="keywordtype">int</span> _image_width, <span class="keywordtype">int</span> _image_height,
<a name="l00357"></a>00357                                                          <span class="keywordtype">double</span> _fx, <span class="keywordtype">double</span> _fy, <span class="keywordtype">double</span> _cx, <span class="keywordtype">double</span> _cy)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359   image_width = original_image_width = _image_width;
<a name="l00360"></a>00360   image_height = original_image_height = _image_height;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   fx = original_fx = _fx;
<a name="l00363"></a>00363   fy = original_fy = _fy;
<a name="l00364"></a>00364   cx = original_cx = _cx;
<a name="l00365"></a>00365   cy = original_cy = _cy;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   have_to_recompute_invAR = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00368"></a>00368 }
<a name="l00369"></a>00369 
<a name="l00370"></a><a class="code" href="classprojection__matrix.html#a0a15161a1c97a47d417a8e32d7b5685">00370</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#be82e2e88b2cc76938f3a5d6a32d3099">projection_matrix::set_original_internal_parameters</a>(<span class="keywordtype">double</span> _fx, <span class="keywordtype">double</span> _fy, <span class="keywordtype">double</span> _cx, <span class="keywordtype">double</span> _cy)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372   fx = original_fx = _fx;
<a name="l00373"></a>00373   fy = original_fy = _fy;
<a name="l00374"></a>00374   cx = original_cx = _cx;
<a name="l00375"></a>00375   cy = original_cy = _cy;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   have_to_recompute_invAR = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a><a class="code" href="classprojection__matrix.html#eb3877cf0a7feb496ea76f843d9b78b4">00380</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#eb3877cf0a7feb496ea76f843d9b78b4">projection_matrix::change_image_size</a>(<span class="keywordtype">int</span> new_width, <span class="keywordtype">int</span> new_height)
<a name="l00381"></a>00381 {
<a name="l00382"></a>00382   image_width = new_width;
<a name="l00383"></a>00383   image_height = new_height;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="keywordtype">double</span> sx = (double)new_width  / original_image_width;
<a name="l00386"></a>00386   <span class="keywordtype">double</span> sy = (double)new_height / original_image_height;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   fx = sx * original_fx;
<a name="l00389"></a>00389   cx = sx * original_cx;
<a name="l00390"></a>00390   fy = sy * original_fy;
<a name="l00391"></a>00391   cy = sy * original_cy;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   have_to_recompute_invAR = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="classprojection__matrix.html#a2224d4f204527196e17241db7a90847">00396</a> <span class="keywordtype">bool</span> <a class="code" href="classprojection__matrix.html#a2224d4f204527196e17241db7a90847">projection_matrix::read_internal_parameters_from_tdir_file</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tdir_filename)
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398   <span class="keywordtype">double</span> tdir_mat[12];
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   FILE * tdir_file = fopen(tdir_filename, <span class="stringliteral">"r"</span>);
<a name="l00401"></a>00401   <span class="keywordflow">if</span> (tdir_file == 0) 
<a name="l00402"></a>00402   {
<a name="l00403"></a>00403     perror(tdir_filename);
<a name="l00404"></a>00404     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 12 ; i++)
<a name="l00408"></a>00408   {
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (fscanf(tdir_file, <span class="stringliteral">"%lf"</span>, &amp;tdir_mat[i]) == EOF)
<a name="l00410"></a>00410     {
<a name="l00411"></a>00411       cout&lt;&lt;<span class="stringliteral">"Error loading file (corrupt or wrong format)"</span>&lt;&lt;endl;
<a name="l00412"></a>00412       fclose(tdir_file);
<a name="l00413"></a>00413       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416   fclose(tdir_file);
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   original_fx = fx = tdir_mat[0];
<a name="l00419"></a>00419   original_fy = fy = tdir_mat[5];
<a name="l00420"></a>00420   original_cx = cx = tdir_mat[2];
<a name="l00421"></a>00421   original_cy = cy = tdir_mat[6];
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00429"></a>00429 <span class="comment">// External parameters:</span>
<a name="l00430"></a>00430 
<a name="l00431"></a><a class="code" href="classprojection__matrix.html#9cd5a8e5051f5b2202dc9176103015df">00431</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#9cd5a8e5051f5b2202dc9176103015df">projection_matrix::set_camera_centre_and_lookat_point</a>(<span class="keywordtype">double</span> Cx, <span class="keywordtype">double</span> Cy, <span class="keywordtype">double</span> Cz, 
<a name="l00432"></a>00432                                                            <span class="keywordtype">double</span> Lx, <span class="keywordtype">double</span> Ly, <span class="keywordtype">double</span> Lz, 
<a name="l00433"></a>00433                                                            <span class="keywordtype">double</span> angle_vertical)
<a name="l00434"></a>00434 {
<a name="l00435"></a>00435   <span class="keywordtype">double</span> rli1[3], rli2[3], rli3[3];
<a name="l00436"></a>00436   <span class="keywordtype">double</span> k[3];
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   rli3[0] = Lx - Cx;
<a name="l00439"></a>00439   rli3[1] = Ly - Cy;
<a name="l00440"></a>00440   rli3[2] = Lz - Cz;
<a name="l00441"></a>00441   <a class="code" href="linear__algebra_8cpp.html#5126ad93f8924331c3809747a6206479">gfla_normalize_3</a>(rli3);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   k[0] = sin(angle_vertical) * rli3[1]; 
<a name="l00444"></a>00444   k[1] = sin(angle_vertical) * rli3[0]; 
<a name="l00445"></a>00445   k[2] = cos(angle_vertical);
<a name="l00446"></a>00446   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(rli3, k, rli1);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(rli3, rli1, rli2);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00451"></a>00451   {
<a name="l00452"></a>00452     R[0][i] = rli1[i];
<a name="l00453"></a>00453     R[1][i] = rli2[i];
<a name="l00454"></a>00454     R[2][i] = rli3[i];
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00458"></a>00458     T[i] = -(R[i][0] * Cx + R[i][1] * Cy + R[i][2] * Cz);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a><a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">00463</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(<span class="keywordtype">double</span> omega, <span class="keywordtype">double</span> phi, <span class="keywordtype">double</span> kappa, 
<a name="l00464"></a>00464                                                 <span class="keywordtype">double</span> Tx, <span class="keywordtype">double</span> Ty, <span class="keywordtype">double</span> Tz)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466   <a class="code" href="linear__algebra_8cpp.html#dbacd17ffe08d63ee8a644e70055f62f">gfla_get_rotation_from_euler_angles</a>(R, omega, phi, kappa);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   T[0] = Tx;
<a name="l00469"></a>00469   T[1] = Ty;
<a name="l00470"></a>00470   T[2] = Tz;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00473"></a>00473 }
<a name="l00474"></a>00474 
<a name="l00475"></a><a class="code" href="classprojection__matrix.html#38c176bf83576abf723ae58772a5d6a9">00475</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(<span class="keywordtype">double</span> * state)
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477   <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">set_external_parameters</a>(state[0], state[1], state[2], state[3], state[4], state[5]);
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00480"></a><a class="code" href="classprojection__matrix.html#0c57ac55a2ea20ce5c30f6eff1e7acdc">00480</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#0c57ac55a2ea20ce5c30f6eff1e7acdc">projection_matrix::set_external_parameters_exp_map</a>(<span class="keywordtype">double</span> * state, CvMat * JR)
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482   <span class="keywordtype">double</span> * om = state;
<a name="l00483"></a>00483   <span class="keywordtype">double</span> * t = state + 3;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="keywordtype">double</span> length = sqrt(om[0] * om[0] + om[1] * om[1] + om[2] * om[2]);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   <span class="keywordflow">if</span> (length &gt; (2 * 3.14159 - 1)) 
<a name="l00488"></a>00488   {
<a name="l00489"></a>00489     <span class="keywordtype">double</span> new_length = fmod(length, 2 * 3.14159);
<a name="l00490"></a>00490     <span class="keywordtype">double</span> r = new_length / length;
<a name="l00491"></a>00491     om[0] *= r;
<a name="l00492"></a>00492     om[1] *= r;
<a name="l00493"></a>00493     om[2] *= r;
<a name="l00494"></a>00494   }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496   <span class="comment">// make the rotation matrix</span>
<a name="l00497"></a>00497   <span class="keywordtype">double</span> rm[9], rv[3];
<a name="l00498"></a>00498   CvMat rotMat = cvMat(3, 3, CV_64FC1, rm);
<a name="l00499"></a>00499   CvMat rotVec = cvMat(1, 3, CV_64FC1, rv);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   cvSetReal1D(&amp;rotVec, 0, om[0]);
<a name="l00502"></a>00502   cvSetReal1D(&amp;rotVec, 1, om[1]);
<a name="l00503"></a>00503   cvSetReal1D(&amp;rotVec, 2, om[2]);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505   <span class="comment">// Compute the rotation matrix</span>
<a name="l00506"></a>00506   cvRodrigues(&amp;rotMat, &amp;rotVec, JR, CV_RODRIGUES_V2M);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="comment">// complete the rotation matrix with translation</span>
<a name="l00509"></a>00509   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00510"></a>00510   {
<a name="l00511"></a>00511     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; j++)
<a name="l00512"></a>00512       R[i][j] = <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(&amp;rotMat, i, j); 
<a name="l00513"></a>00513     T[i] = t[i];
<a name="l00514"></a>00514   }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a><a class="code" href="classprojection__matrix.html#4339117e0544e7c9dcd0fccb61506bb0">00519</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#4339117e0544e7c9dcd0fccb61506bb0">projection_matrix::get_external_parameters_exp_map</a>(<span class="keywordtype">double</span> * state)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521   <span class="comment">// make the rotation matrix</span>
<a name="l00522"></a>00522   <span class="keywordtype">double</span> rm[9], rv[3];
<a name="l00523"></a>00523   CvMat rotMat = cvMat(3, 3, CV_64FC1, rm);
<a name="l00524"></a>00524   CvMat rotVec = cvMat(1, 3, CV_64FC1, rv);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="comment">// Compute the rotation matrix</span>
<a name="l00527"></a>00527   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00528"></a>00528     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; j++)
<a name="l00529"></a>00529       <a class="code" href="affinity_8h.html#b946d622b301d5c7c44c8f9561bfe349">cvmSet</a>(&amp;rotMat, i, j, R[i][j]); 
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   cvRodrigues(&amp;rotMat, &amp;rotVec, 0, CV_RODRIGUES_M2V);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   state[0] = rv[0];
<a name="l00534"></a>00534   state[1] = rv[1];
<a name="l00535"></a>00535   state[2] = rv[2];
<a name="l00536"></a>00536 
<a name="l00537"></a>00537   state[3] = T[0];
<a name="l00538"></a>00538   state[4] = T[1];
<a name="l00539"></a>00539   state[5] = T[2];
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00542"></a><a class="code" href="classprojection__matrix.html#32d9942636504c2fb334370a4379d0f7">00542</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(<span class="keywordtype">double</span> wc2vc[3][4])
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00545"></a>00545   {
<a name="l00546"></a>00546     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; j++)
<a name="l00547"></a>00547       R[i][j] = wc2vc[i][j];
<a name="l00548"></a>00548     T[i] = wc2vc[i][3];
<a name="l00549"></a>00549   }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a><a class="code" href="classprojection__matrix.html#0566ba174793ddd95c15ec9ce8a91b27">00554</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(<span class="keywordtype">double</span> ** wc2vc)
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00557"></a>00557   {
<a name="l00558"></a>00558     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; j++)
<a name="l00559"></a>00559       R[i][j] = wc2vc[i][j];
<a name="l00560"></a>00560     T[i] = wc2vc[i][3];
<a name="l00561"></a>00561   }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a><a class="code" href="classprojection__matrix.html#20320b3de989a2cf7a21e9d95c736a95">00566</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(<span class="keywordtype">double</span> rot[3][3], <span class="keywordtype">double</span> transl[3])
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568   <a class="code" href="linear__algebra_8cpp.html#2fd7f823ed13ef80bbf7f107eace90db">gfla_copy_3x3</a>(rot, R);
<a name="l00569"></a>00569   <a class="code" href="linear__algebra_8cpp.html#d4470ae6b1e9aeb6dac4275f1e5ef868">gfla_copy_3</a>(transl, T);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00572"></a>00572 }
<a name="l00573"></a>00573 
<a name="l00574"></a><a class="code" href="classprojection__matrix.html#48049e0dc06eb9ff8808c0a6d9499f7f">00574</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#48049e0dc06eb9ff8808c0a6d9499f7f">projection_matrix::set_rotation_to_Id</a>(<span class="keywordtype">void</span>)
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576   R[0][0] = 1; R[0][1] = 0; R[0][2] = 0;
<a name="l00577"></a>00577   R[1][0] = 0; R[1][1] = 1; R[1][2] = 0;
<a name="l00578"></a>00578   R[2][0] = 0; R[2][1] = 0; R[2][2] = 1;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00583"></a><a class="code" href="classprojection__matrix.html#df9584f53925de31c767217e909c685b">00583</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#df9584f53925de31c767217e909c685b">projection_matrix::set_translation_to_0</a>(<span class="keywordtype">void</span>)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585   T[0] = T[1] = T[2] = 0.;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a><a class="code" href="classprojection__matrix.html#1d13756b97350896f372d0192a94e4d0">00590</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">projection_matrix::set_external_parameters</a>(CvMat * H)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592   <span class="keywordtype">double</span> AH1[3], AH2[3];
<a name="l00593"></a>00593   <span class="keywordtype">double</span> inv_fx = 1. / fx, inv_fy = 1. / fy;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   AH1[0] = inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 0, 0) - cx * inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 0);
<a name="l00596"></a>00596   AH1[1] = inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 1, 0) - cy * inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 0);
<a name="l00597"></a>00597   AH1[2] =                                          <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 0);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   AH2[0] = inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 0, 1) - cx * inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 1);
<a name="l00600"></a>00600   AH2[1] = inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 1, 1) - cy * inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 1);
<a name="l00601"></a>00601   AH2[2] =                                          <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 1);
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   T[0] = inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 0, 2) - cx * inv_fx * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 2);
<a name="l00604"></a>00604   T[1] = inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 1, 2) - cy * inv_fy * <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 2);
<a name="l00605"></a>00605   T[2] =                                          <a class="code" href="affinity_8h.html#83234dc742ec651acf71ef8b48d33045">cvmGet</a>(H, 2, 2);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordtype">double</span> norm2_AH1 = AH1[0] * AH1[0] + AH1[1] * AH1[1] + AH1[2] * AH1[2];
<a name="l00608"></a>00608   <span class="keywordtype">double</span> norm2_AH2 = AH2[0] * AH2[0] + AH2[1] * AH2[1] + AH2[2] * AH2[2];
<a name="l00609"></a>00609   <span class="keywordtype">double</span> inv_l = 1. / sqrt( sqrt(norm2_AH1 * norm2_AH2) );
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="keywordtype">double</span> R1[3], R2[3];
<a name="l00612"></a>00612   <a class="code" href="linear__algebra_8cpp.html#baa95767ce4d92b88acffcf9661ac7e5">gfla_scale_3</a>(inv_l, AH1, R1);
<a name="l00613"></a>00613   <a class="code" href="linear__algebra_8cpp.html#baa95767ce4d92b88acffcf9661ac7e5">gfla_scale_3</a>(inv_l, AH2, R2);
<a name="l00614"></a>00614   <a class="code" href="linear__algebra_8cpp.html#baa95767ce4d92b88acffcf9661ac7e5">gfla_scale_3</a>(inv_l, T);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   <span class="keywordtype">double</span> c[3], p[3], d[3];
<a name="l00617"></a>00617   <a class="code" href="linear__algebra_8cpp.html#856a96b5b69c59d022004a197db902f7">gfla_add_3</a>(R1, R2, c);
<a name="l00618"></a>00618   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(R1, R2, p);
<a name="l00619"></a>00619   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(c,  p,  d);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <a class="code" href="linear__algebra_8cpp.html#5126ad93f8924331c3809747a6206479">gfla_normalize_3</a>(c);
<a name="l00622"></a>00622   <a class="code" href="linear__algebra_8cpp.html#5126ad93f8924331c3809747a6206479">gfla_normalize_3</a>(d);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keywordtype">double</span> R1p[3], R2p[3], R3p[3];
<a name="l00625"></a>00625   <a class="code" href="linear__algebra_8cpp.html#856a96b5b69c59d022004a197db902f7">gfla_add_3</a>(c, d, R1p);
<a name="l00626"></a>00626   <a class="code" href="linear__algebra_8cpp.html#baa95767ce4d92b88acffcf9661ac7e5">gfla_scale_3</a>(1. / sqrt(2.), R1p);
<a name="l00627"></a>00627 
<a name="l00628"></a>00628   <a class="code" href="linear__algebra_8cpp.html#00c2a153d99a3333fb39046669cb6ffa">gfla_sub_3</a>(c, d, R2p);
<a name="l00629"></a>00629   <a class="code" href="linear__algebra_8cpp.html#baa95767ce4d92b88acffcf9661ac7e5">gfla_scale_3</a>(1. / sqrt(2.), R2p);
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(R1p, R2p, R3p);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00634"></a>00634   {
<a name="l00635"></a>00635     R[i][0] = R1p[i]; 
<a name="l00636"></a>00636     R[i][1] = R2p[i]; 
<a name="l00637"></a>00637     R[i][2] = R3p[i];
<a name="l00638"></a>00638   }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   cout &lt;&lt; *<span class="keyword">this</span> &lt;&lt; endl;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00643"></a>00643 }
<a name="l00644"></a>00644 
<a name="l00645"></a><a class="code" href="classprojection__matrix.html#6850c97c12edd8751cdf17607d78ca2b">00645</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#6850c97c12edd8751cdf17607d78ca2b">projection_matrix::translate_x</a>(<span class="keywordtype">double</span> delta)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647   T[0] += delta;
<a name="l00648"></a>00648   have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 
<a name="l00652"></a><a class="code" href="classprojection__matrix.html#3ed2b6cf1896696a794113c4a4a29bad">00652</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#3ed2b6cf1896696a794113c4a4a29bad">projection_matrix::translate_y</a>(<span class="keywordtype">double</span> delta)
<a name="l00653"></a>00653 {
<a name="l00654"></a>00654   T[1] += delta;
<a name="l00655"></a>00655   have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 
<a name="l00659"></a><a class="code" href="classprojection__matrix.html#c3817f64789f6a4fea85fc6b9314cd13">00659</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#c3817f64789f6a4fea85fc6b9314cd13">projection_matrix::translate_z</a>(<span class="keywordtype">double</span> delta)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661   T[2] += delta;
<a name="l00662"></a>00662   have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="classprojection__matrix.html#583ecd17b5ce1a1df4953490e704d0b7">00666</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#583ecd17b5ce1a1df4953490e704d0b7">projection_matrix::rotate_x</a>(<span class="keywordtype">double</span> delta)
<a name="l00667"></a>00667 { 
<a name="l00668"></a>00668   <span class="keywordtype">double</span> par[6];
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">get_external_parameters</a>(&amp;par[0], &amp;par[1], &amp;par[2], &amp;par[3], &amp;par[4], &amp;par[5]);
<a name="l00671"></a>00671   par[0] += delta;
<a name="l00672"></a>00672   <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">set_external_parameters</a>(par[0], par[1], par[2], par[3], par[4], par[5]);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a><a class="code" href="classprojection__matrix.html#22fdf894b65e9867f2506828bd60d724">00677</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#22fdf894b65e9867f2506828bd60d724">projection_matrix::rotate_y</a>(<span class="keywordtype">double</span> delta)
<a name="l00678"></a>00678 { 
<a name="l00679"></a>00679   <span class="keywordtype">double</span> par[6];
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">get_external_parameters</a>(&amp;par[0], &amp;par[1], &amp;par[2], &amp;par[3], &amp;par[4], &amp;par[5]);
<a name="l00682"></a>00682   par[1] += delta;
<a name="l00683"></a>00683   <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">set_external_parameters</a>(par[0], par[1], par[2], par[3], par[4], par[5]);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00686"></a>00686 }
<a name="l00687"></a>00687 
<a name="l00688"></a><a class="code" href="classprojection__matrix.html#fff10af5e79ebaef8a43efd9e4307950">00688</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#fff10af5e79ebaef8a43efd9e4307950">projection_matrix::rotate_z</a>(<span class="keywordtype">double</span> delta)
<a name="l00689"></a>00689 { 
<a name="l00690"></a>00690   <span class="keywordtype">double</span> par[6];
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">get_external_parameters</a>(&amp;par[0], &amp;par[1], &amp;par[2], &amp;par[3], &amp;par[4], &amp;par[5]);
<a name="l00693"></a>00693   par[2] += delta;
<a name="l00694"></a>00694   <a class="code" href="classprojection__matrix.html#01c37fdf4a5cc2df48de7b666ac4123a">set_external_parameters</a>(par[0], par[1], par[2], par[3], par[4], par[5]);
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   have_to_recompute_invAR = have_to_recompute_optical_centre = have_to_recompute_P = <span class="keyword">true</span>;
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a><a class="code" href="classprojection__matrix.html#ff71daddcbfc7ce4fa5ef68095887fd7">00699</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">projection_matrix::get_external_parameters</a>(<span class="keywordtype">double</span> * state)
<a name="l00700"></a>00700 {
<a name="l00701"></a>00701   <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">get_external_parameters</a>(&amp;state[0], &amp;state[1], &amp;state[2], &amp;state[3], &amp;state[4], &amp;state[5]);
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a><a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">00704</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#b93e1c47ede810e3331795aab412d530">projection_matrix::get_external_parameters</a>(<span class="keywordtype">double</span> * omega, <span class="keywordtype">double</span> * phi, <span class="keywordtype">double</span> * kappa,
<a name="l00705"></a>00705                                                 <span class="keywordtype">double</span> * Tx, <span class="keywordtype">double</span> * Ty, <span class="keywordtype">double</span> * Tz)
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707   <a class="code" href="linear__algebra_8cpp.html#61af0221fb5b86acadfb31ceacd52df1">gfla_get_euler_angles_from_rotation</a>(R, omega, phi, kappa);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709   *Tx = T[0];
<a name="l00710"></a>00710   *Ty = T[1];
<a name="l00711"></a>00711   *Tz = T[2];
<a name="l00712"></a>00712 }
<a name="l00713"></a>00713 
<a name="l00714"></a><a class="code" href="classprojection__matrix.html#faf1bf30745289aaf0973853a3f8ac40">00714</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#faf1bf30745289aaf0973853a3f8ac40">projection_matrix::world_to_cam</a>(<span class="keywordtype">double</span> * M, <span class="keywordtype">double</span> * Mc)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716   <span class="keywordflow">if</span> (M != Mc)
<a name="l00717"></a>00717   {
<a name="l00718"></a>00718     Mc[0] = R[0][0] * M[0] + R[0][1] * M[1] + R[0][2] * M[2] + T[0];
<a name="l00719"></a>00719     Mc[1] = R[1][0] * M[0] + R[1][1] * M[1] + R[1][2] * M[2] + T[1];
<a name="l00720"></a>00720     Mc[2] = R[2][0] * M[0] + R[2][1] * M[1] + R[2][2] * M[2] + T[2];
<a name="l00721"></a>00721   }
<a name="l00722"></a>00722   <span class="keywordflow">else</span>
<a name="l00723"></a>00723   {
<a name="l00724"></a>00724     <span class="keywordtype">double</span> M2[3];
<a name="l00725"></a>00725     M2[0] = R[0][0] * M[0] + R[0][1] * M[1] + R[0][2] * M[2] + T[0];
<a name="l00726"></a>00726     M2[1] = R[1][0] * M[0] + R[1][1] * M[1] + R[1][2] * M[2] + T[1];
<a name="l00727"></a>00727     M2[2] = R[2][0] * M[0] + R[2][1] * M[1] + R[2][2] * M[2] + T[2];
<a name="l00728"></a>00728     Mc[0] = M2[0];
<a name="l00729"></a>00729     Mc[1] = M2[1];
<a name="l00730"></a>00730     Mc[2] = M2[2];
<a name="l00731"></a>00731   }
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 
<a name="l00735"></a>00735 <span class="comment">// Projection matrix:</span>
<a name="l00736"></a>00736 
<a name="l00737"></a><a class="code" href="classprojection__matrix.html#367689696be5cb2b7993b1f93beedcbb">00737</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#367689696be5cb2b7993b1f93beedcbb">projection_matrix::get_3x4_matrix</a>(<span class="keywordtype">double</span> pP[3][4])
<a name="l00738"></a>00738 {
<a name="l00739"></a>00739   <span class="keywordflow">if</span> (have_to_recompute_P)
<a name="l00740"></a>00740     compute_P();
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <a class="code" href="linear__algebra_8cpp.html#8f59022a39cda076849fd600ccb6bd37">gfla_copy_3x4</a>(P, pP);
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00746"></a>00746 <span class="comment">// Optical centre:</span>
<a name="l00747"></a>00747 
<a name="l00748"></a><a class="code" href="classprojection__matrix.html#9f958ae963a383223ec4deeb1b3d9473">00748</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#4ee6cc02832d8d7fdce23255e66e61f4">projection_matrix::get_optical_centre</a>(<span class="keywordtype">double</span> * Cx, <span class="keywordtype">double</span> * Cy, <span class="keywordtype">double</span> * Cz)
<a name="l00749"></a>00749 {
<a name="l00750"></a>00750   <span class="keywordflow">if</span> (have_to_recompute_optical_centre)
<a name="l00751"></a>00751     compute_optical_centre();
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   *Cx = optical_centre[0];
<a name="l00754"></a>00754   *Cy = optical_centre[1];
<a name="l00755"></a>00755   *Cz = optical_centre[2];
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a><a class="code" href="classprojection__matrix.html#4ee6cc02832d8d7fdce23255e66e61f4">00758</a> <span class="keywordtype">double</span> * <a class="code" href="classprojection__matrix.html#4ee6cc02832d8d7fdce23255e66e61f4">projection_matrix::get_optical_centre</a>(<span class="keywordtype">void</span>)
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760   <span class="keywordflow">if</span> (have_to_recompute_optical_centre)
<a name="l00761"></a>00761     compute_optical_centre();
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   <span class="keywordflow">return</span> optical_centre;
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00767"></a>00767 <span class="comment">// Ray casting:</span>
<a name="l00768"></a>00768 
<a name="l00769"></a><a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">00769</a> <span class="keywordtype">double</span> * <a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">projection_matrix::get_V</a>(<span class="keywordtype">double</span> u, <span class="keywordtype">double</span> v)
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771   <span class="keywordtype">double</span> * V = <span class="keyword">new</span> <span class="keywordtype">double</span>[3];
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">get_V</a>(u, v, V);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775   <span class="keywordflow">return</span> V;
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 
<a name="l00778"></a><a class="code" href="classprojection__matrix.html#ee8cc7fa1e32fe6ef0c6113d4f160fa8">00778</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">projection_matrix::get_V</a>(<span class="keywordtype">double</span> u, <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> * V)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780   <span class="keywordflow">if</span> (have_to_recompute_invAR)
<a name="l00781"></a>00781     compute_invAR();
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   V[0] = invAR[0][0] * u + invAR[0][1] * v + invAR[0][2];
<a name="l00784"></a>00784   V[1] = invAR[1][0] * u + invAR[1][1] * v + invAR[1][2];
<a name="l00785"></a>00785   V[2] = invAR[2][0] * u + invAR[2][1] * v + invAR[2][2];
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <a class="code" href="linear__algebra_8cpp.html#5126ad93f8924331c3809747a6206479">gfla_normalize_3</a>(V);
<a name="l00788"></a>00788 }
<a name="l00789"></a>00789 
<a name="l00790"></a><a class="code" href="classprojection__matrix.html#8191eb34fc9056d79e7d4e61f40b0977">00790</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">projection_matrix::get_V</a>(<span class="keywordtype">double</span> u, <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> * Vx, <span class="keywordtype">double</span> * Vy, <span class="keywordtype">double</span> * Vz)
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792   <span class="keywordflow">if</span> (have_to_recompute_invAR)
<a name="l00793"></a>00793     compute_invAR();
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   *Vx = invAR[0][0] * u + invAR[0][1] * v + invAR[0][2];
<a name="l00796"></a>00796   *Vy = invAR[1][0] * u + invAR[1][1] * v + invAR[1][2];
<a name="l00797"></a>00797   *Vz = invAR[2][0] * u + invAR[2][1] * v + invAR[2][2];
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="keywordtype">double</span> inv_norme = 1. / <a class="code" href="linear__algebra_8cpp.html#eabcb831ee2d9d0ef1bc868d0934a66a">gfla_norme</a>(*Vx, *Vy, *Vz);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   *Vx *= inv_norme;
<a name="l00802"></a>00802   *Vy *= inv_norme;
<a name="l00803"></a>00803   *Vz *= inv_norme;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00807"></a>00807 <span class="comment">// OpenGL:</span>
<a name="l00808"></a>00808 
<a name="l00809"></a><a class="code" href="classprojection__matrix.html#52c7afd1dc91593a9962d9a7a1fb7d78">00809</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#52c7afd1dc91593a9962d9a7a1fb7d78">projection_matrix::set_GL_zmin_zmax</a>(<span class="keywordtype">double</span> zmin, <span class="keywordtype">double</span> zmax)
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811   planes[4] = zmin;
<a name="l00812"></a>00812   planes[5] = zmax;
<a name="l00813"></a>00813 }
<a name="l00814"></a>00814 
<a name="l00815"></a><a class="code" href="classprojection__matrix.html#648cf3132bd4bbced2736b5f708a7c17">00815</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#648cf3132bd4bbced2736b5f708a7c17">projection_matrix::set_GL_PROJECTION</a>(<span class="keywordtype">int</span> xdim, <span class="keywordtype">int</span> ydim, <span class="keywordtype">float</span> * gl_vector)
<a name="l00816"></a>00816 {
<a name="l00817"></a>00817   <span class="keywordtype">double</span> tdir[3][4], <a class="code" href="yape_8cpp.html#f933676109efed7ab34cea71d748a517">S</a>[3][3], Stdir[3][4];
<a name="l00818"></a>00818   <span class="keywordtype">float</span> gl_mat[4][4];
<a name="l00819"></a>00819   <span class="keywordtype">double</span> zmin = planes[4], zmax = planes[5], zratio = 2.0 / (zmax - zmin);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00822"></a>00822     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00823"></a>00823       tdir[i][j] = 0.;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   tdir[0][0] = fx;
<a name="l00826"></a>00826   tdir[1][1] = fy;
<a name="l00827"></a>00827   tdir[0][2] = cx;
<a name="l00828"></a>00828   tdir[1][2] = cy;
<a name="l00829"></a>00829   tdir[2][2] = 1.;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   S[0][0] = 2. / xdim; S[0][1] = 0.;        S[0][2] = -1.;
<a name="l00832"></a>00832   S[1][0] = 0.;        S[1][1] = 2. / ydim; S[1][2] = -1.;
<a name="l00833"></a>00833   S[2][0] = 0.;        S[2][1] = 0.;        S[2][2] =  1.;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <a class="code" href="linear__algebra_8cpp.html#759d86ad7e23112a8880f068f80f3027">gfla_mul_mat_3x3x4</a>(S, tdir, Stdir);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00838"></a>00838   {
<a name="l00839"></a>00839     gl_mat[j][0] = float(Stdir[0][j]);
<a name="l00840"></a>00840     gl_mat[j][1] = float(Stdir[1][j]); 
<a name="l00841"></a>00841     gl_mat[j][3] = float(Stdir[2][j]); 
<a name="l00842"></a>00842   }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="comment">// Plane distance computation in 3rd column:</span>
<a name="l00845"></a>00845   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00846"></a>00846     gl_mat[j][2] = <span class="keywordtype">float</span>( planes[j] * zratio );
<a name="l00847"></a>00847   gl_mat[3][2]= float( -(1.0 + gl_mat[3][2] + zmin * zratio) );
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) 
<a name="l00850"></a>00850     gl_mat[i][1] = -gl_mat[i][1];
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)
<a name="l00853"></a>00853     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00854"></a>00854       gl_vector[j + 4 * i] = gl_mat[i][j];
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a><a class="code" href="classprojection__matrix.html#6f7a79f383af500939952eb07b231331">00857</a> <span class="keywordtype">void</span> <a class="code" href="classprojection__matrix.html#6f7a79f383af500939952eb07b231331">projection_matrix::set_GL_MODELVIEW</a>(<span class="keywordtype">double</span> * gl_vector)
<a name="l00858"></a>00858 {
<a name="l00859"></a>00859   gl_vector[0*4+0] = R[0][0]; gl_vector[0*4+1] = R[1][0]; gl_vector[0*4+2] = R[2][0]; gl_vector[0*4+3] = 0.;
<a name="l00860"></a>00860   gl_vector[1*4+0] = R[0][1]; gl_vector[1*4+1] = R[1][1]; gl_vector[1*4+2] = R[2][1]; gl_vector[1*4+3] = 0.;
<a name="l00861"></a>00861   gl_vector[2*4+0] = R[0][2]; gl_vector[2*4+1] = R[1][2]; gl_vector[2*4+2] = R[2][2]; gl_vector[2*4+3] = 0.;
<a name="l00862"></a>00862   gl_vector[3*4+0] = T[0];    gl_vector[3*4+1] = T[1];    gl_vector[3*4+2] = T[2];    gl_vector[3*4+3] = 1.;
<a name="l00863"></a>00863 }
<a name="l00864"></a>00864 
<a name="l00865"></a><a class="code" href="classprojection__matrix.html#7ddf61843679d901230481155d7192a6">00865</a> <span class="keywordtype">bool</span> <a class="code" href="classprojection__matrix.html#7ddf61843679d901230481155d7192a6">projection_matrix::visible_triangle</a>(<span class="keywordtype">double</span> X1, <span class="keywordtype">double</span> Y1, <span class="keywordtype">double</span> Z1,
<a name="l00866"></a>00866                                          <span class="keywordtype">double</span> X2, <span class="keywordtype">double</span> Y2, <span class="keywordtype">double</span> Z2,
<a name="l00867"></a>00867                                          <span class="keywordtype">double</span> X3, <span class="keywordtype">double</span> Y3, <span class="keywordtype">double</span> Z3)
<a name="l00868"></a>00868 {
<a name="l00869"></a>00869   <span class="keywordtype">double</span> V[3], n[3];
<a name="l00870"></a>00870   <a class="code" href="classprojection__matrix.html#b1727181ea6eb0946cc6901e82952c67">get_V</a>(cx, cy, V);
<a name="l00871"></a>00871   <span class="keywordtype">double</span> M1M2[3], M1M3[3];
<a name="l00872"></a>00872   M1M2[0] = X2 - X1; M1M2[1] = Y2 - Y1; M1M2[2] = Z2 - Z1;
<a name="l00873"></a>00873   M1M3[0] = X3 - X1; M1M3[1] = Y3 - Y1; M1M3[2] = Z3 - Z1;
<a name="l00874"></a>00874   <a class="code" href="linear__algebra_8cpp.html#4732edb2dc4c0c721261180e84244a9c">gfla_cross_product</a>(M1M2, M1M3, n);
<a name="l00875"></a>00875   <span class="keywordflow">return</span> <a class="code" href="linear__algebra_8cpp.html#74a7d4e236e8d9e698ac48ebdf2cbd6d">gfla_dot_product</a>(n, V) &lt; 0;
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 
<a name="l00879"></a>00879 <span class="comment">// Internal functions:</span>
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="keywordtype">void</span> projection_matrix::compute_invAR(<span class="keywordtype">void</span>)
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883   <span class="keywordtype">double</span> t4, t6, t8, t10, t12, t14, t16, t19, t24, t27, t28, t30, t32, t34, t35, t37, t39, t43, t52, t55, t57, t59;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   t4 = 1/fx;
<a name="l00886"></a>00886   t6 = R[0][0]*R[2][2];
<a name="l00887"></a>00887   t8 = R[0][0]*R[2][1];
<a name="l00888"></a>00888   t10 = R[1][0]*R[2][2];
<a name="l00889"></a>00889   t12 = R[2][1]*R[1][0];
<a name="l00890"></a>00890   t14 = R[2][0]*R[0][1];
<a name="l00891"></a>00891   t16 = R[2][0]*R[0][2];
<a name="l00892"></a>00892   t19 = 1/(t6*R[1][1]-t8*R[1][2]-t10*R[0][1]+t12*R[0][2]+t14*R[1][2]-t16*R[1][1]);
<a name="l00893"></a>00893   t24 = 1/fy;
<a name="l00894"></a>00894   t27 = fx*R[0][1];
<a name="l00895"></a>00895   t28 = R[1][2]*fy;
<a name="l00896"></a>00896   t30 = cy*R[2][2];
<a name="l00897"></a>00897   t32 = cx*R[2][1];
<a name="l00898"></a>00898   t34 = fx*R[0][2];
<a name="l00899"></a>00899   t35 = fy*R[1][1];
<a name="l00900"></a>00900   t37 = cy*R[2][1];
<a name="l00901"></a>00901   t39 = cx*R[2][2];
<a name="l00902"></a>00902   t43 = t24*t19;
<a name="l00903"></a>00903   t52 = fx*R[0][0];
<a name="l00904"></a>00904   t55 = cx*R[2][0];
<a name="l00905"></a>00905   t57 = fy*R[1][0];
<a name="l00906"></a>00906   t59 = cy*R[2][0];
<a name="l00907"></a>00907 
<a name="l00908"></a>00908   invAR[0][0] = (R[1][1]*R[2][2]-R[2][1]*R[1][2])*t4*t19;
<a name="l00909"></a>00909   invAR[0][1] = -(R[2][2]*R[0][1]-R[2][1]*R[0][2])*t24*t19;
<a name="l00910"></a>00910   invAR[0][2] = (t27*t28+t27*t30+t32*t28-t34*t35-t34*t37-t39*t35)*t4*t43;
<a name="l00911"></a>00911   invAR[1][0] = -(t10-R[2][0]*R[1][2])*t4*t19;
<a name="l00912"></a>00912   invAR[1][1] = (t6-t16)*t24*t19;
<a name="l00913"></a>00913   invAR[1][2] = -(t52*t28+t52*t30+t55*t28-t34*t57-t34*t59-t39*t57)*t4*t43;
<a name="l00914"></a>00914   invAR[2][0] = (t12-R[2][0]*R[1][1])*t4*t19;
<a name="l00915"></a>00915   invAR[2][1] = -(t8-t14)*t24*t19;
<a name="l00916"></a>00916   invAR[2][2] = (t52*t35+t52*t37+t55*t35-t27*t57-t27*t59-t32*t57)*t4*t43;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   have_to_recompute_invAR = <span class="keyword">false</span>;
<a name="l00919"></a>00919 }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921 <span class="keywordtype">void</span> projection_matrix::compute_optical_centre(<span class="keywordtype">void</span>)
<a name="l00922"></a>00922 {
<a name="l00925"></a>00925   optical_centre[0] = -(R[0][0] * T[0] + R[1][0] * T[1] + R[2][0] * T[2]);
<a name="l00926"></a>00926   optical_centre[1] = -(R[0][1] * T[0] + R[1][1] * T[1] + R[2][1] * T[2]);
<a name="l00927"></a>00927   optical_centre[2] = -(R[0][2] * T[0] + R[1][2] * T[1] + R[2][2] * T[2]);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   have_to_recompute_optical_centre = <span class="keyword">false</span>;
<a name="l00930"></a>00930 }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="keywordtype">void</span> projection_matrix::compute_P(<span class="keywordtype">void</span>)
<a name="l00933"></a>00933 {
<a name="l00934"></a>00934   <span class="keywordtype">double</span> A[3][3];
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   A[0][0] = fx; A[0][1] = 0.; A[0][2] = cx;
<a name="l00937"></a>00937   A[1][0] = 0.; A[1][1] = fy; A[1][2] = cy;
<a name="l00938"></a>00938   A[2][0] = 0.; A[2][1] = 0.; A[2][2] = 1.;
<a name="l00939"></a>00939 
<a name="l00940"></a>00940   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00941"></a>00941     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
<a name="l00942"></a>00942     {
<a name="l00943"></a>00943       P[i][j] = 0;
<a name="l00944"></a>00944       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 3; k++)
<a name="l00945"></a>00945         <span class="keywordflow">if</span> (j &lt; 3)
<a name="l00946"></a>00946           P[i][j] += A[i][k] * R[k][j];
<a name="l00947"></a>00947         <span class="keywordflow">else</span>
<a name="l00948"></a>00948           P[i][j] += A[i][k] * T[k];
<a name="l00949"></a>00949     }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951     have_to_recompute_P = <span class="keyword">false</span>;
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 17 16:17:17 2009 for bazar by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
