<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>bazar: /home/julian/devel/artvertiser/garfeild/calib/CamCalibration.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_1be09642b1728ac69a5f1a111e5847b4.html">garfeild</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_286043b3351fad96a251ea738bb3e48e.html">calib</a>
  </div>
</div>
<div class="contents">
<h1>CamCalibration.h</h1><a href="CamCalibration_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef _CAMCALIBRATION_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define _CAMCALIBRATION_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#ifndef M_PI</span>
<a name="l00005"></a><a class="code" href="CamCalibration_8h.html#e71449b1cc6e6250b91f539153a7a0d3">00005</a> <span class="preprocessor"></span><span class="preprocessor">#define M_PI 3.1415926535897932384626433832795</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;cv.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="code" href="homography_8h.html">geometry/homography.h</a>&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">struct </span><a class="code" href="structProjObs.html">ProjObs</a>;
<a name="l00017"></a>00017 
<a name="l00037"></a><a class="code" href="classCamCalibration.html">00037</a> <span class="keyword">class </span><a class="code" href="classCamCalibration.html" title="Calibrates one or more cameras from homographies and 2D/3D correspondances.">CamCalibration</a> {
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00043"></a>00043   <a class="code" href="classCamCalibration.html#835a96282df800eb80066be3bc6ec8be" title="Constructor of the CamCalibration class.">CamCalibration</a>();
<a name="l00044"></a>00044 
<a name="l00051"></a>00051   <a class="code" href="classCamCalibration.html#12d59330236687a2804317c430e81364" title="Deconstructor of the CamCalibration class.">~CamCalibration</a>();
<a name="l00052"></a>00052 
<a name="l00061"></a>00061   <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#6655adc794e3a63871fa1a00622bf0e5" title="Add a camera.">AddCamera</a>( <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height );
<a name="l00062"></a>00062 
<a name="l00071"></a>00071   <span class="keywordtype">bool</span> <a class="code" href="classCamCalibration.html#c2f59bc26a9a182d6e56f8d834501958" title="Add an empty homography (without data) to camera c.">AddHomography</a>( <span class="keywordtype">int</span> c );
<a name="l00072"></a>00072 
<a name="l00083"></a><a class="code" href="structCamCalibration_1_1s__struct__points.html">00083</a>   <span class="keyword">struct </span><a class="code" href="structCamCalibration_1_1s__struct__points.html" title="Transfer structure for AddHomography().">s_struct_points</a> {
<a name="l00084"></a><a class="code" href="structCamCalibration_1_1s__struct__points.html#4c969669ce984c4cccfb1b7cf4390c40">00084</a>     <span class="keywordtype">double</span> <a class="code" href="structCamCalibration_1_1s__struct__points.html#5c6f059bd544329423c1c31fd4598766">u</a>,<a class="code" href="structCamCalibration_1_1s__struct__points.html#31efca215580cf55611c5b5e80aeac27">v</a>,<a class="code" href="structCamCalibration_1_1s__struct__points.html#472cf7eeaa49327c46cbd3775d04c7ff">x</a>,<a class="code" href="structCamCalibration_1_1s__struct__points.html#4c969669ce984c4cccfb1b7cf4390c40">y</a>;
<a name="l00085"></a><a class="code" href="structCamCalibration_1_1s__struct__points.html#f349cbe69140e55c82363fa82456a7da">00085</a>     <a class="code" href="structCamCalibration_1_1s__struct__points.html#f349cbe69140e55c82363fa82456a7da">s_struct_points</a>(){}
<a name="l00086"></a><a class="code" href="structCamCalibration_1_1s__struct__points.html#3775a27db15b99eaaf6610f97c6f4478">00086</a>     <a class="code" href="structCamCalibration_1_1s__struct__points.html#f349cbe69140e55c82363fa82456a7da">s_struct_points</a>( <span class="keywordtype">double</span> <a class="code" href="structCamCalibration_1_1s__struct__points.html#5c6f059bd544329423c1c31fd4598766">u</a>, <span class="keywordtype">double</span> <a class="code" href="structCamCalibration_1_1s__struct__points.html#31efca215580cf55611c5b5e80aeac27">v</a>, <span class="keywordtype">double</span> <a class="code" href="structCamCalibration_1_1s__struct__points.html#472cf7eeaa49327c46cbd3775d04c7ff">x</a>, <span class="keywordtype">double</span> <a class="code" href="structCamCalibration_1_1s__struct__points.html#4c969669ce984c4cccfb1b7cf4390c40">y</a> ) : u(u), v(v), x(x), y(y) {}
<a name="l00087"></a>00087   };
<a name="l00088"></a>00088 
<a name="l00100"></a>00100   <span class="keywordtype">bool</span> <a class="code" href="classCamCalibration.html#c2f59bc26a9a182d6e56f8d834501958" title="Add an empty homography (without data) to camera c.">AddHomography</a>( <span class="keywordtype">int</span> c, std::vector&lt;CamCalibration::s_struct_points&gt; p, CvMat* ready );
<a name="l00101"></a>00101 
<a name="l00110"></a>00110   <span class="keywordtype">bool</span> <a class="code" href="classCamCalibration.html#f575f25b3b9f56b0a6440a7328b6453d" title="Stores initial homography structure to file.">StoreHomographiesToFile</a>( <span class="keywordtype">char</span>* file_name );
<a name="l00111"></a>00111 
<a name="l00119"></a>00119   <span class="keywordtype">bool</span> <a class="code" href="classCamCalibration.html#8af5f64b1f60f13b61f18968bb86c019" title="Loads initial homography structure from file.">LoadHomographiesFromFile</a>( <span class="keywordtype">char</span>* file_name );
<a name="l00120"></a>00120 
<a name="l00142"></a>00142   <span class="keywordtype">bool</span> <a class="code" href="classCamCalibration.html#efb86cba9d0b1120492fa20c7630dcc3" title="Starts the camera calibration process.">Calibrate</a>( <span class="keywordtype">int</span> p_HomographyNum, <span class="keywordtype">int</span> p_PreFilter, <span class="keywordtype">int</span> p_Solutions, <span class="keywordtype">double</span> p_PreFilter_a, <span class="keywordtype">double</span> p_PreFilter_b, <span class="keywordtype">double</span> p_PreFilter_c,
<a name="l00143"></a>00143     <span class="keywordtype">double</span> p_InitialGuess_a, <span class="keywordtype">double</span> p_InitialGuess_b, <span class="keywordtype">double</span> p_InitialGuess_c,
<a name="l00144"></a>00144     <span class="keywordtype">int</span> p_Iterations, <span class="keywordtype">double</span> p_Epsilon, <span class="keywordtype">double</span> p_PostFilter );
<a name="l00145"></a>00145 
<a name="l00161"></a>00161   <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#77d0e9a3b955b231429b8a8591678a73" title="Prints resulting matrices seperated to 3 files.">PrintOptimizedResultsToFile1</a>();
<a name="l00162"></a>00162 
<a name="l00177"></a>00177   <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#a1212ba8b7dc4370b1ab207a34be0b3b" title="Prints resulting projection matrices to many separated files.">PrintOptimizedResultsToFile2</a>(  <span class="keywordtype">char</span>* file_descriptor, <span class="keywordtype">bool</span> create_png = <span class="keyword">false</span>, <span class="keywordtype">char</span>* sequence_descriptor = <span class="stringliteral">""</span>, 
<a name="l00178"></a>00178     <span class="keywordtype">char</span>* png_descriptor = <span class="stringliteral">""</span>, <span class="keywordtype">int</span> c_start = 0, <span class="keywordtype">int</span> h_start = 0 );
<a name="l00179"></a>00179 
<a name="l00181"></a>00181   <span class="comment">// Functions below this line are used by CamCalibration and CamAugmentation only ! //</span>
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00189"></a>00189   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#3f73623b55ea301c9182d30bb6f5cc7d" title="Decomposes RotTrans into Rot and Trans.">ExtractRotationTranslationFrom3x4Matrix</a>( CvMat* RotTrans , CvMat* Rot, CvMat*Trans );
<a name="l00190"></a>00190 
<a name="l00196"></a>00196   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#ccc0ecfaf423205e92272933ebc69f81" title="Composes Rot and Trans to RotTrans.">ComposeRotationTranslationTo3x4Matrix</a>( CvMat* RotTrans , CvMat* Rot, CvMat*Trans );
<a name="l00197"></a>00197 
<a name="l00201"></a>00201   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#72512fecde3966d4a6c174fe9e4e98a5" title="Multiplies 3x4 matrices m_A and m_B to m_C.">Mat3x4Mul</a>( CvMat* m_A, CvMat* m_B, CvMat* m_C );
<a name="l00202"></a>00202 
<a name="l00206"></a>00206   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#ab6280fa0d5f6aacb927a2a3d5a0f390" title="Inverts 3x4 matrix m_A and stores result to m_B.">Mat3x4Inverse</a>( CvMat* m_A, CvMat* m_B );
<a name="l00207"></a>00207 
<a name="l00211"></a>00211   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#4a3e0e96065af75497352233aff004bb" title="Divides mat by its last element.">HomogenousNormalizeVector</a>( CvMat* mat );
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#115f18512e9e4ea9a2deff650d4f2198">PlotPointsToImagesAfterOptimization</a>();
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <span class="keywordtype">void</span> <a class="code" href="classCamCalibration.html#b754eff7b6bfbf6a9c184e141a7c7bdb">ClearAll</a>();
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">private</span>:
<a name="l00218"></a>00218 
<a name="l00231"></a>00231   <span class="keyword">struct </span>s_struct_plane {
<a name="l00232"></a>00232     <span class="keywordtype">int</span>                 p;
<a name="l00233"></a>00233     <span class="keywordtype">double</span>             *px;
<a name="l00234"></a>00234     <span class="keywordtype">double</span>             *py;
<a name="l00235"></a>00235     std::vector&lt;CvMat*&gt; v_m_wp;
<a name="l00236"></a>00236     std::vector&lt;CvMat*&gt; v_m_pp;
<a name="l00237"></a>00237     <span class="keywordtype">double</span>              rx,ry,rz;
<a name="l00238"></a>00238     <span class="keywordtype">double</span>              tx,ty,tz;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     s_struct_plane() {
<a name="l00241"></a>00241       px     = NULL;
<a name="l00242"></a>00242       py     = NULL;
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     ~s_struct_plane() {
<a name="l00246"></a>00246       <span class="keyword">delete</span> px;
<a name="l00247"></a>00247       <span class="keyword">delete</span> py;
<a name="l00248"></a>00248       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; (int)v_m_wp.size(); i++ ) cvReleaseMat(&amp;v_m_wp[i]);
<a name="l00249"></a>00249       v_m_wp.clear();
<a name="l00250"></a>00250       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; (int)v_m_pp.size(); i++ ) cvReleaseMat(&amp;v_m_pp[i]);
<a name="l00251"></a>00251       v_m_pp.clear();
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253   };
<a name="l00254"></a>00254 
<a name="l00267"></a>00267   <span class="keyword">struct </span>s_struct_homography {
<a name="l00268"></a>00268     s_struct_plane*    s_plane_object;
<a name="l00269"></a>00269     <a class="code" href="classhomography.html" title="Static class for the estimation of homographies.Provides functions to estimate the...">homography</a>*     m_homography;
<a name="l00270"></a>00270     CvMat*      m_estim_r_t_matrix;
<a name="l00271"></a>00271     CvMat*      m_jacobian_matrix;
<a name="l00272"></a>00272     <span class="keywordtype">bool</span>      b_discard;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     s_struct_homography(){
<a name="l00275"></a>00275       s_plane_object     = <span class="keyword">new</span> s_struct_plane();
<a name="l00276"></a>00276       b_discard     = <span class="keyword">true</span>; <span class="comment">// specifies discarding candidates</span>
<a name="l00277"></a>00277       m_homography       = NULL; <span class="comment">// NULL  = not valid!</span>
<a name="l00278"></a>00278       m_estim_r_t_matrix = cvCreateMat( 3, 4, CV_64FC1 );
<a name="l00279"></a>00279       m_jacobian_matrix  = cvCreateMat( 3, 9, CV_64FC1 );
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281     ~s_struct_homography(){
<a name="l00282"></a>00282       <span class="keywordflow">if</span>( s_plane_object ) <span class="keyword">delete</span> s_plane_object;
<a name="l00283"></a>00283       <span class="keywordflow">if</span>( m_homography   ) <span class="keyword">delete</span> m_homography;
<a name="l00284"></a>00284       cvReleaseMat(&amp;m_estim_r_t_matrix);
<a name="l00285"></a>00285       cvReleaseMat(&amp;m_jacobian_matrix );
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287   };
<a name="l00288"></a>00288 
<a name="l00294"></a>00294   <span class="keyword">struct </span>s_struct_intrinsic {
<a name="l00295"></a>00295     <span class="keywordtype">double</span> focal;
<a name="l00296"></a>00296     <span class="keywordtype">double</span> aspect;
<a name="l00297"></a>00297     <span class="keywordtype">double</span> u0,v0;
<a name="l00298"></a>00298   };
<a name="l00299"></a>00299 
<a name="l00311"></a>00311   <span class="keyword">struct </span>s_struct_camera {
<a name="l00312"></a>00312     <span class="keywordtype">int</span>         w,h;
<a name="l00313"></a>00313     s_struct_intrinsic     s_intrinsic;
<a name="l00314"></a>00314     s_struct_intrinsic     s_estim_int;
<a name="l00315"></a>00315     std::vector&lt;s_struct_homography*&gt; v_homography;
<a name="l00316"></a>00316     CvMat*        m_calibration_matrix;
<a name="l00317"></a>00317     CvMat*        m_rot_trans_matrix;
<a name="l00318"></a>00318     CvMat*        m_estim_calib_matrix;
<a name="l00319"></a>00319     CvMat*        m_estinvcalib_matrix;  
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     s_struct_camera( <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height ){
<a name="l00322"></a>00322       w = width;
<a name="l00323"></a>00323       h = height;
<a name="l00324"></a>00324       m_calibration_matrix = cvCreateMat( 3, 3, CV_64FC1 );
<a name="l00325"></a>00325       m_rot_trans_matrix   = cvCreateMat( 3, 4, CV_64FC1 );
<a name="l00326"></a>00326       m_estim_calib_matrix = cvCreateMat( 3, 3, CV_64FC1 );
<a name="l00327"></a>00327       m_estinvcalib_matrix = cvCreateMat( 3, 3, CV_64FC1 );
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     ~s_struct_camera(){
<a name="l00331"></a>00331       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; (int)v_homography.size(); i++ ) <span class="keyword">delete</span> v_homography[i];
<a name="l00332"></a>00332       v_homography.clear();
<a name="l00333"></a>00333       cvReleaseMat(&amp;m_calibration_matrix);
<a name="l00334"></a>00334       cvReleaseMat(&amp;m_rot_trans_matrix  );
<a name="l00335"></a>00335       cvReleaseMat(&amp;m_estim_calib_matrix);
<a name="l00336"></a>00336       cvReleaseMat(&amp;m_estinvcalib_matrix);
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338   };
<a name="l00339"></a>00339 
<a name="l00343"></a>00343   std::vector&lt;s_struct_camera*&gt; v_camera;
<a name="l00344"></a>00344 
<a name="l00348"></a>00348   <span class="keyword">struct </span>s_struct_solution {
<a name="l00349"></a>00349     <span class="keywordtype">int</span> c,h;
<a name="l00350"></a>00350     s_struct_solution( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h ) : c(c), h(h) {}
<a name="l00351"></a>00351   };
<a name="l00352"></a>00352 
<a name="l00362"></a>00362   <span class="keyword">struct </span>s_struct_optimal {
<a name="l00363"></a>00363     <span class="keywordtype">int</span>     c_max, h_max;
<a name="l00364"></a>00364     std::vector&lt;CvMat*&gt; v_camera_c;
<a name="l00365"></a>00365     std::vector&lt;CvMat*&gt; v_camera_r_t;
<a name="l00366"></a>00366     std::vector&lt;CvMat*&gt; v_camera_r_t_jacobian;
<a name="l00367"></a>00367     std::vector&lt;CvMat*&gt; v_homography_r_t;
<a name="l00368"></a>00368     std::vector&lt;CvMat*&gt; v_homography_r_t_jacobian;
<a name="l00370"></a>00370     <span class="comment">/*deleteall(){</span>
<a name="l00371"></a>00371 <span class="comment">    for( int i = 0; i &lt; (int)v_camera_c.size(); i++ )</span>
<a name="l00372"></a>00372 <span class="comment">    if( v_camera_c[i] ) cvReleaseMat( &amp;v_camera_c[i] );</span>
<a name="l00373"></a>00373 <span class="comment">    v_camera_c.clear();</span>
<a name="l00374"></a>00374 <span class="comment">    for( int i = 0; i &lt; (int)v_camera_r_t.size(); i++ )</span>
<a name="l00375"></a>00375 <span class="comment">    if( v_camera_r_t[i] ) cvReleaseMat( &amp;v_camera_r_t[i] );</span>
<a name="l00376"></a>00376 <span class="comment">    v_camera_r_t.clear();</span>
<a name="l00377"></a>00377 <span class="comment">    for( int i = 0; i &lt; (int)v_camera_r_t_jacobian.size(); i++ )</span>
<a name="l00378"></a>00378 <span class="comment">    if( v_camera_r_t_jacobian[i] ) cvReleaseMat( &amp;v_camera_r_t_jacobian[i] );</span>
<a name="l00379"></a>00379 <span class="comment">    v_camera_r_t_jacobian.clear();</span>
<a name="l00380"></a>00380 <span class="comment">    for( int i = 0; i &lt; (int)v_homography_r_t.size(); i++ )</span>
<a name="l00381"></a>00381 <span class="comment">    if( v_homography_r_t[i] ) cvReleaseMat( &amp;v_homography_r_t[i] );</span>
<a name="l00382"></a>00382 <span class="comment">    v_homography_r_t.clear();</span>
<a name="l00383"></a>00383 <span class="comment">    for( int i = 0; i &lt; (int)v_homography_r_t_jacobian.size(); i++ )</span>
<a name="l00384"></a>00384 <span class="comment">    if( v_homography_r_t_jacobian[i] ) cvReleaseMat( &amp;v_homography_r_t_jacobian[i] );</span>
<a name="l00385"></a>00385 <span class="comment">    v_homography_r_t_jacobian.clear();</span>
<a name="l00386"></a>00386 <span class="comment">    }*/</span>
<a name="l00387"></a>00387     s_struct_optimal(){
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389     ~s_struct_optimal(){
<a name="l00390"></a>00390       <span class="comment">//deleteall();</span>
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392   };
<a name="l00393"></a>00393 
<a name="l00400"></a>00400   s_struct_optimal s_optimal;
<a name="l00401"></a>00401 
<a name="l00412"></a>00412   std::vector&lt;double&gt; v_opt_param;
<a name="l00413"></a>00413 
<a name="l00424"></a>00424   CvMat *m_CH;
<a name="l00425"></a>00425 
<a name="l00431"></a>00431   <span class="keyword">enum</span> matrix_desc { m_calibration,
<a name="l00432"></a>00432     m_rot_trans,
<a name="l00433"></a>00433     m_estim_calib,
<a name="l00434"></a>00434     m_estinvcalib,
<a name="l00435"></a>00435     m_estim_r_t,
<a name="l00436"></a>00436     m_jacobian };
<a name="l00437"></a>00437 
<a name="l00445"></a>00445   <span class="keywordtype">int</span>  errorgraphic_counter;
<a name="l00446"></a>00446 
<a name="l00450"></a>00450   <span class="keywordtype">int</span>  stat_HomographyNum;
<a name="l00451"></a>00451 
<a name="l00455"></a>00455   time_t stat_ExpStartTime;
<a name="l00456"></a>00456 
<a name="l00460"></a>00460   <span class="keywordtype">double</span>  GetRandomValue( <span class="keywordtype">double</span> min, <span class="keywordtype">double</span> max );
<a name="l00461"></a>00461 
<a name="l00465"></a>00465   <span class="keywordtype">void</span>    AddGaussianNoise( CvMat* mat, <span class="keywordtype">double</span> noise );
<a name="l00466"></a>00466 
<a name="l00475"></a>00475   <span class="keywordtype">void</span> SetIntrinsicParam( <span class="keywordtype">int</span> c, <span class="keywordtype">double</span> f, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> u, <span class="keywordtype">double</span> v );
<a name="l00476"></a>00476 
<a name="l00486"></a>00486   <span class="keywordtype">void</span> SetPlaneObject( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> p, <span class="keywordtype">double</span> px[], <span class="keywordtype">double</span> py[],
<a name="l00487"></a>00487     <span class="keywordtype">double</span> rx, <span class="keywordtype">double</span> ry, <span class="keywordtype">double</span> rz, <span class="keywordtype">double</span> tx, <span class="keywordtype">double</span> ty, <span class="keywordtype">double</span> tz );
<a name="l00488"></a>00488 
<a name="l00496"></a>00496   <span class="keywordtype">void</span> CreateCalibrationMatrixFromIntrinsicParameters( <span class="keywordtype">int</span> c );
<a name="l00497"></a>00497 
<a name="l00504"></a>00504   <span class="keywordtype">void</span> CreateEstimatedCalibrationMatrixFromEstimatedIntrinsicParameters( <span class="keywordtype">int</span> c );
<a name="l00505"></a>00505 
<a name="l00512"></a>00512   <span class="keywordtype">void</span> CreateEstimatedInverseCalibrationMatrixFromEstimatedIntrinsicParameters( <span class="keywordtype">int</span> c );
<a name="l00513"></a>00513 
<a name="l00521"></a>00521   <span class="keywordtype">void</span>    CreateRotationTranslationMatrixFromInverseCalibrationMatrixAndHomography( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h );
<a name="l00522"></a>00522 
<a name="l00529"></a>00529   <span class="keywordtype">void</span>    CreateAllRotationTranslationMatrices( <span class="keywordtype">int</span> c );
<a name="l00530"></a>00530 
<a name="l00537"></a>00537   <span class="keywordtype">void</span>    CreateRotationTranslationIdentityMatrix( <span class="keywordtype">int</span> c );
<a name="l00538"></a>00538 
<a name="l00545"></a>00545   <span class="keywordtype">void</span>    CreateRotationTranslationMatrix( <span class="keywordtype">int</span> c, <span class="keywordtype">double</span> rx, <span class="keywordtype">double</span> ry, <span class="keywordtype">double</span> rz,
<a name="l00546"></a>00546     <span class="keywordtype">double</span> tx, <span class="keywordtype">double</span> ty, <span class="keywordtype">double</span> tz );
<a name="l00547"></a>00547 
<a name="l00554"></a>00554   <span class="keywordtype">void</span> CreatePlaneObjectWorldPoints( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h );
<a name="l00555"></a>00555 
<a name="l00562"></a>00562   <span class="keywordtype">void</span> CreatePlaneObjectPlanePoints( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h, <span class="keywordtype">double</span> noise );
<a name="l00563"></a>00563 
<a name="l00570"></a>00570   <span class="keywordtype">void</span> CreateWorldPlaneHomography( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h, CvMat* ready );
<a name="l00571"></a>00571 
<a name="l00579"></a>00579   <span class="keywordtype">bool</span>    HomographySingular( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h, <span class="keywordtype">double</span> p_InitialGuess_a, <span class="keywordtype">double</span> p_InitialGuess_b, <span class="keywordtype">double</span> p_InitialGuess_c );
<a name="l00580"></a>00580 
<a name="l00584"></a>00584   <span class="keywordtype">double</span>  VectorAngle( CvMat* v1, CvMat* v2, CvMat* v3, CvMat* v4 );
<a name="l00585"></a>00585 
<a name="l00589"></a>00589   <span class="keywordtype">double</span>  PointDistance( CvMat* v1, CvMat* v2 );
<a name="l00590"></a>00590 
<a name="l00594"></a>00594   <span class="keywordtype">void</span>    DeleteWorldPlaneHomography( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h );
<a name="l00595"></a>00595 
<a name="l00599"></a>00599   std::vector&lt;s_struct_solution&gt; GetRandomSolution( <span class="keywordtype">int</span> num );
<a name="l00600"></a>00600 
<a name="l00607"></a>00607   <span class="keywordtype">double</span> GetScreenDistance( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h1, <span class="keywordtype">int</span> h2 );
<a name="l00608"></a>00608 
<a name="l00615"></a>00615   <span class="keywordtype">double</span>  GetSolutionQuality( std::vector&lt;s_struct_solution&gt; solution, <span class="keywordtype">double</span> p_PreFilter_a, <span class="keywordtype">double</span> p_PreFilter_b, <span class="keywordtype">double</span> p_PreFilter_c );
<a name="l00616"></a>00616 
<a name="l00624"></a>00624   <span class="keywordtype">bool</span>    FilterBestHomographiesGreedyMethod( <span class="keywordtype">int</span> num );
<a name="l00625"></a>00625 
<a name="l00640"></a>00640   <span class="keywordtype">bool</span>    FilterBestHomographiesFillingMethod( <span class="keywordtype">int</span> num, <span class="keywordtype">double</span> p_PreFilter_a );
<a name="l00641"></a>00641 
<a name="l00653"></a>00653   <span class="keywordtype">bool</span>    FilterBestHomographiesRandomMethod( <span class="keywordtype">int</span> num, <span class="keywordtype">int</span> p_Solutions, <span class="keywordtype">double</span> p_PreFilter_a, <span class="keywordtype">double</span> p_PreFilter_b, <span class="keywordtype">double</span> p_PreFilter_c );
<a name="l00654"></a>00654 
<a name="l00662"></a>00662   <span class="keywordtype">bool</span>    ExtractIntrinsicParameters( <span class="keywordtype">int</span> c, <span class="keywordtype">double</span> p_InitialGuess_a, <span class="keywordtype">double</span> p_InitialGuess_b, <span class="keywordtype">double</span> p_InitialGuess_c );
<a name="l00663"></a>00663 
<a name="l00669"></a>00669   <span class="keywordtype">double</span>  GetFrobeniusDistance( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h1, <span class="keywordtype">int</span> h2 );
<a name="l00670"></a>00670 
<a name="l00676"></a>00676   <span class="keywordtype">bool</span>    GetDistalHomographiesForCalibration( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> *h1, <span class="keywordtype">int</span> *h2 );
<a name="l00677"></a>00677 
<a name="l00684"></a>00684   <span class="keywordtype">bool</span> FilterHomographiesAfterOptimization( <span class="keywordtype">double</span> p_PostFilter );
<a name="l00685"></a>00685 
<a name="l00695"></a>00695   <span class="keywordtype">bool</span> OptimizeCalibrationByMinimalParameterMethod( <span class="keywordtype">int</span> iter, <span class="keywordtype">double</span> eps, <span class="keywordtype">double</span> p_PostFilter );
<a name="l00696"></a>00696 
<a name="l00705"></a>00705   <span class="keywordtype">bool</span>    CreateMatrixCH();
<a name="l00706"></a>00706 
<a name="l00710"></a>00710   <span class="keywordtype">void</span>    GetParameterSetFromOptimalStructure();
<a name="l00711"></a>00711 
<a name="l00715"></a>00715   <span class="keywordtype">void</span>    SetParameterSetToOptimalStructure();
<a name="l00716"></a>00716 
<a name="l00722"></a>00722   <span class="keywordtype">void</span>    CreateEstimated3ChainMatrixRT( <span class="keywordtype">int</span> h1, <span class="keywordtype">int</span> c1, <span class="keywordtype">int</span> h2, <span class="keywordtype">int</span> c2 );
<a name="l00723"></a>00723 
<a name="l00730"></a>00730   <span class="keywordtype">void</span> CreateEstimatedOptimalHomographyMatrixRT( <span class="keywordtype">int</span> h1, <span class="keywordtype">int</span> c1, <span class="keywordtype">int</span> h2 );
<a name="l00731"></a>00731 
<a name="l00737"></a>00737   <span class="keywordtype">void</span> CreateEstimatedOptimalCameraMatrixRT( <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h );
<a name="l00738"></a>00738 
<a name="l00742"></a>00742   <span class="keywordtype">void</span> CreateEstimatedOptimalCameraMatrixC( <span class="keywordtype">int</span> c );
<a name="l00743"></a>00743 
<a name="l00752"></a>00752   <span class="keywordtype">bool</span> CreateOptimalCameraStructure();
<a name="l00753"></a>00753 
<a name="l00760"></a>00760   <span class="keywordtype">void</span> ReleaseOptimalCameraStructure();
<a name="l00761"></a>00761 
<a name="l00767"></a>00767   <span class="keywordtype">int</span>     GetParameterNumber();
<a name="l00768"></a>00768 
<a name="l00772"></a>00772   <span class="keywordtype">int</span>     GetObservationNumber();
<a name="l00773"></a>00773 
<a name="l00779"></a>00779   CvMat* GetM( <span class="keyword">enum</span> matrix_desc desc, <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> h );
<a name="l00780"></a>00780 
<a name="l00784"></a>00784   <span class="keywordtype">void</span> Translate3DVector( CvMat* v, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z );
<a name="l00785"></a>00785 
<a name="l00791"></a>00791   <span class="keywordtype">void</span> Rotate3DVector( CvMat* v, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z );
<a name="l00792"></a>00792 
<a name="l00798"></a>00798   <span class="keyword">static</span> <span class="keywordtype">void</span> Mat3x4ToMat4x4( CvMat* m_A, CvMat* m_B );
<a name="l00799"></a>00799 
<a name="l00805"></a>00805   <span class="keyword">static</span> <span class="keywordtype">void</span> Mat4x4ToMat3x4( CvMat* m_A, CvMat* m_B );
<a name="l00806"></a>00806 
<a name="l00812"></a>00812   <span class="keyword">static</span> <span class="keywordtype">void</span> updateCB(<span class="keywordtype">double</span> *params, <span class="keywordtype">void</span> **user_data);
<a name="l00813"></a>00813 
<a name="l00826"></a>00826   <span class="comment">//static void projFunc( double *x, double *params, int na, double *f, double *grad, int *ind, LsqData *Data );</span>
<a name="l00827"></a>00827 
<a name="l00831"></a>00831   <span class="keywordtype">void</span> PrintOptimizedResultErrors(  <span class="keywordtype">double</span> *params );
<a name="l00832"></a>00832 
<a name="l00838"></a>00838   <span class="keywordtype">void</span> PrintStatisticToFile();
<a name="l00839"></a>00839 
<a name="l00840"></a><a class="code" href="classCamCalibration.html#b67315aaf5a20cf2f82bc712316376bb">00840</a>   <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="structProjObs.html">ProjObs</a>;
<a name="l00841"></a>00841 };
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 17 16:17:17 2009 for bazar by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
